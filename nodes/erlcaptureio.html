<script type="text/javascript">
  (function(){
  

  function frontendSupportFunction() {
  }

  var functTwo = (arg) => {

  };
  
  RED.nodes.registerType('erlcaptureio',{
    color: '#FFAAAA',
    icon: "font-awesome/fa-medkit",
    category: 'processes',
    paletteLabel: 'CaptureIO',
    defaults: {
      name: {
        value:"",
      },

      scope: { value: "flow", type: "*[]", required: true }

    },

    inputs: 1,

    outputs: 1,

    label: function () {
      if (this.name) {
        return this.name;
      }
      if (this.scope === "group") {
        return this._("erlcaptureio.captureGroup");
      } else if (Array.isArray(this.scope)) {
        return this._("erlcaptureio.nodeCount", { number: this.scope.length });
      }
      return this._("erlcaptureio.captureFlow")
    },

    labelStyle: function () {
      return this.name ? "node_label_italic" : "";
    },

    // called when node is added to workspace also if copied and pasted.
    // once for each node added to the workspace
    onadd: function() {
    },

    // called when node added to palette - one time
    onpaletteadd: function() {
    },

    onpaletteremove: function() {
    },

    oneditprepare: function() {
      var node = this;

      var scope = node.scope || [];

      this._resize = function () {
        var rows = $("#dialog-form>div:not(.node-input-target-list-row)");
        var height = $("#dialog-form").height();
        for (var i = 0; i < rows.length; i++) {
          height -= $(rows[i]).outerHeight(true);
        }
        var editorRow = $("#dialog-form>div.node-input-target-list-row");
        editorRow.css("height", height + "px");
      };

      var search = $("#node-input-erlcaptureio-target-filter").searchBox({
        style: "compact",
        delay: 300,
        change: function () {
          var val = $(this).val().trim().toLowerCase();
          if (val === "") {
            dirList.treeList("filter", null);
            search.searchBox("count", "");
          } else {
            var count = dirList.treeList("filter", function (item) {
              return item.label.toLowerCase().indexOf(val) > -1 || item.node.type.toLowerCase().indexOf(val) > -1
            });
            search.searchBox("count", count + " / " + candidateNodes.length);
          }
        }
      });  

      var dirList = $("#node-input-erlcaptureio-target-container-div").css({
        width: "100%",
        height: "100%"
      }).treeList({
        multi: true,
        sortable: false
      }).on("treelistitemmouseover", function (e, item) {
        item.node.highlighted = true;
        item.node.dirty = true;
        RED.view.redraw();
      }).on("treelistitemmouseout", function (e, item) {
        item.node.highlighted = false;
        item.node.dirty = true;
        RED.view.redraw();
      })

      var candidateNodes = RED.nodes.filterNodes({ z: node.z });
      var items = [];
      var scopedItems = [];
      var nodeItemMap = {};

      candidateNodes.forEach(function (n) {
        if (n.id === node.id || !["function", "erlprocess", "erlgenserver", "erlstatemachine", "erleventhandler"].includes(n.type)) {
          return;
        }
        var isChecked = scope.indexOf(n.id) !== -1;

        var nodeDef = RED.nodes.getType(n.type);
        var label;
        var sublabel;
        if (nodeDef) {
          var l = nodeDef.label;
          label = (typeof l === "function" ? l.call(n) : l) || "";
          sublabel = n.type;
          if (sublabel.indexOf("subflow:") === 0) {
            var subflowId = sublabel.substring(8);
            var subflow = RED.nodes.subflow(subflowId);
            sublabel = "subflow : " + subflow.name;
          }
        }
        if (!nodeDef || !label) {
          label = n.type;
        }

        nodeItemMap[n.id] = {
          node: n,
          id: n.id,
          label: label,
          sublabel: sublabel,
          selected: isChecked,
          checkbox: true
        };

        if (isChecked) {
          scopedItems.push(nodeItemMap[n.id]);
        } else {
          items.push(nodeItemMap[n.id]);
        }
      });

      scopedItems.sort((a, b) => { return scope.indexOf(a.id) < scope.indexOf(b.id) ? -1 : 1 })

      dirList.treeList('data', [...scopedItems, ...items]);

      $("#node-input-erlcaptureio-target-select").on("click", function (e) {
        e.preventDefault();
        var preselected = dirList.treeList('selected').map(function (n) { return n.node.id });
        RED.tray.hide();
        RED.view.selectNodes({
          selected: preselected,
          onselect: function (selection) {
            RED.tray.show();
            var newlySelected = {};
            selection.forEach(function (n) {
              newlySelected[n.id] = true;
              if (nodeItemMap[n.id]) {
                nodeItemMap[n.id].treeList.select(true);
              }
            })
            preselected.forEach(function (id) {
              if (!newlySelected[id]) {
                nodeItemMap[id].treeList.select(false);
              }
            })
          },
          oncancel: function () {
            RED.tray.show();
          },
          filter: function (n) {
            return n.id !== node.id && ["function","erlprocess","erlgenserver","erlstatemachine","erleventhandler"].includes(n.type);
          }
        });
      })

      $("#node-input-scope-select").on("change", function (e) {
        var scope = $(this).val();
        if (scope === "target") {
          $(".node-input-target-row").show();
        } else {
          $(".node-input-target-row").hide();
        }
        node._resize();
      });

      if (this.scope === null || this.scope === "flow") {
        $("#node-input-scope-select").val("flow");
      } else if (this.scope === "group") {
        $("#node-input-scope-select").val("group");
      } else {
        $("#node-input-scope-select").val("target");
      }
      
      $("#node-input-scope-select").trigger("change");
    },

    oneditcancel: function() {
    },

    oneditsave: function() {
      var scope = $("#node-input-scope-select").val();
      if (scope === null || scope === 'flow') {
        this.scope = 'flow';
      } else if (scope === 'group') {
        this.scope = "group";
      } else {
        // this seems to be the only way to get the list of ids in sorted ordered ...
        this.scope = Array.from($("#node-input-erlcaptureio-target-container-div").find('li').find('.selected').map((d, o) => $($(o).parent()).data().data.id))
      }      
    },

    oneditresize: function(size) {
      this._resize();
    },


  });
})();

</script>

<script type="text/html" data-template-name="erlcaptureio">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red:common.label.name"></span></label>
    <input type="text" id="node-input-name" data-i18n="[placeholder]node-red:common.label.name">
  </div>
  

  <div class="form-row">
    <label style="width: 150px;" for="node-input-scope" data-i18n="erlcaptureio.label.source"></label>
    <select id="node-input-scope-select">
                  <option value="flow" data-i18n="erlcaptureio.scope.all"></option>
                  <option value="group" data-i18n="erlcaptureio.scope.group"></option>
                  <option value="target" data-i18n="erlcaptureio.scope.selected"></option>
              </select>
  </div>
  
  <div class="form-row node-input-target-row">
    <button type="button" id="node-input-erlcaptureio-target-select" class="red-ui-button" data-i18n="node-red:common.label.selectNodes"></button>
  </div>
  
  <div class="form-row node-input-target-row node-input-target-list-row" style="position: relative; min-height: 100px">
    <div style="position: absolute; top: -30px; right: 0;"><input type="text" id="node-input-erlcaptureio-target-filter">
    </div>
    <div id="node-input-erlcaptureio-target-container-div"></div>
  </div>

</script>
